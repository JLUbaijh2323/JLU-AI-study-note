
---

### 📚 数据结构·期末冲刺复习计划

#### 模块一：基础与“标尺” (《1-2绪论.pptx》)

🎯 核心复习目标：

重新精通本课程的“度量衡”——时空复杂度。如果你不能熟练分析复杂度，你就无法“深入”比较任何两个算法。

**✅ 必做行动清单：**

1. **重看概念：** 快速过一遍“数据”、“数据元素” 1、“数据项” 2、“逻辑结构”（线性/非线性） 3333和“存储结构”（顺序/链接） 4。
    
2. **推导复杂度：**
    
    - **不要**只是“背” $O(1), O(\log n), O(n), O(n \log n), O(n^2)$ 5。
        
    - **拿出纸笔**，打开《绪论》第34页的例子（`++x;` 那个） 6，**亲手推导**为什么它的执行频度是 $n(n+1)/2$，从而时间复杂度为 $O(n^2)$。
        
    - **自己写一个**：写一个二分查找的伪代码，并推导为什么它的时间复杂度是对数阶 $O(\log n)$。
        

**⚖️ 深入理解标准：**

- **（基础）** 能随口说出 $O(1), O(\log n), O(n), O(n \log n), O(n^2)$ 的典型算法。
    
- **（深入）** 拿到一个包含2-3层循环的陌生代码片段，能**立即分析**出它的最坏情况时间复杂度。
    

---

#### 模块二：线性结构 (《3 线性表 堆栈 队列.pptx》)

🎯 核心复习目标：

彻底搞懂“顺序存储”和“链式存储”的本质区别和性能权衡 (Trade-off)。栈和队列是这个模块的**“实战应用”**。

**✅ 必做行动清单：**

1. **对比表 (顺序表 vs. 链表)：**
    
    - **画一个表**，对比两者在“随机存取 (Get)” 7777、“插入 (Insert)” 8888、“删除 (Delete)” 9999 上的**平均**和**最坏**时间复杂度。
        
2. **重绘指针操作 (单链表)：**
    
    - 这是**绝对的重点**。“模糊”通常发生在这里。
        
    - **亲手画出**《线性表》第28页的**“在p结点后插入s”** 10101010，并**默写**出那两行核心代码 (`s->next = p->next; p->next = s;`)。
        
    - **亲手画出**《线性表》第31页的**“删除p的后继结点q”** 11111111，并**默写**出那三行核心代码。
        
3. **重绘指针操作 (栈与队列)：**
    
    - **栈：** 画出“链栈”的“入栈 (Push)” 12和“出栈 (Pop)” 13 操作，理解为什么它们都是 $O(1)$。
        
    - **队列 (难点)：**
        
        - **顺序循环队列：** 在纸上画一个大小为5的数组，模拟 `front` 和 `rear` 指针的移动。**必须搞清楚**“假溢出” 14，以及循环队列是如何解决它的 15。**必须默写**“队满”和“队空”的两种判断条件（牺牲一个单元 16或 `count` 计数器 17）。
            
        - **链式队列：** **必须画图**理解为什么需要 `front` 和 `rear` 两个指针 18。**重点关注**“出队”操作 19，当删除最后一个元素时，`rear` 指针也必须被置为 `NULL` 20。
            

**⚖️ 深入理解标准：**

- **（基础）** 能默写所有增删改查操作的代码。
    
- **（深入）** 能清晰地向别人解释：
    
    1. 为什么顺序队列会“假溢出”？
        
    2. 为什么链式队列（出队）在只剩一个元素时需要特殊处理？
        
    3. 为什么中缀表达式转后缀表达式需要用“栈”？（重做一遍PPT第100页的例子 21）
        

---

#### 模块三：特殊线性结构 (《04 数组和字符串.pptx》)

🎯 核心复习目标：

掌握多维数组的地址计算，并彻底攻克KMP算法。

**✅ 必做行动清单：**

1. **数组地址：**
    
    - **默写公式：** 必须背诵并理解二维数组 $A[m][n]$ 的“按行优先” 22地址计算公式：`Loc(a[i][j]) = Loc(a[0][0]) + (i * n + j) * C` 23。
        
    - **推导：** 将此公式推广到三维 $A[m][n][p]$ 24。
        
2. **稀疏矩阵：**
    
    - **理解：** 核心思想是“压缩”。
        
    - **复习：** “三元组表” {行, 列, 值} 25是如何节省空间的 26。
        
3. **KMP算法 (本章最大难点)：**
    
    - **回顾朴素算法：** 朴素算法的 `i` 指针（主串）和 `j` 指针（模式串）在失配时都会回溯 27。
        
    - **KMP核心思想：** `i` 指针（主串）**永不回溯** 28282828。
        
    - **攻克 `next` 数组：**
        
        1. **理解含义：** `next[j]` 的含义是：当模式串 $P$ 的 $P[j]$ 字符失配时，`j` 应该回退到哪个位置 `k` 29。
            
        2. **理解 `k`：** `k` 的值是 $P[0 \dots j-1]$ 这段子串的**“最长公共前后缀”**的长度 30303030。
            
        3. **手动推导 (必须做)：** 拿出纸笔，**推导《数组和字符串》第59页**的例子 `P = "ababaa"`（PPT中是另一个例子 `ababa` 31），一步一步写出 `next` 数组的推导过程。
            
    - **默写匹配代码：** 默写KMP算法的**匹配过程**（`while (k > -1 && ...)` 的回溯循环） 32。
        

**⚖️ 深入理解标准：**

- **（基础）** 能计算二维数组的地址。
    
- **（深入）** 能在**10分钟内**，**不看书**，准确推导出任意一个长度为8的字符串的 `next` 数组，并能解释每一步的推导依据。
    

---

#### 模块四：树与二叉树 (《05 第五章 樹与二叉树(2).pptx》)

🎯 核心复习目标：

遍历是树的一切。 必须掌握所有遍历方式（递归与非递归）、树/森林/二叉树的转换、以及哈夫曼树的构造。

**✅ 必做行动清单：**

1. **背诵性质：**
    
    - $n_0 = n_2 + 1$ （叶子 = 度为2的结点 + 1） 33。
        
    - 具有 $n$ 个结点的**完全二叉树** 34，高度为 $\lfloor \log_2 n \rfloor$ 35。
        
2. **背诵“下标数学”：** 必须记住完全二叉树的顺序存储下标关系（假设根在`A[1]`）：`parent(i) = floor(i/2)`, `left(i) = 2i`, `right(i) = 2i+1` 36363636。**（这是堆排序的基础）**
    
3. **默写遍历 (核心)：**
    
    - **递归：** 必须能随手默写**先根(DLR)** 37、**中根(LDR)** 38、**后根(LRD)** 39 的递归代码。
        
    - **非递归 (难点)：**
        
        - **中根 (用栈)：** 在纸上模拟一遍“指针`p`一路向左，沿途**入栈**；`p`为空时，**出栈**一个结点、**访问**它、`p`转向**右孩子**” 40。
            
        - **层次 (用队列)：** 在纸上模拟一遍“根**入队**；`while`队列不空：结点**出队**、**访问**、**左孩子入队**、**右孩子入队**” 41414141。
            
4. **重建树 (必考)：**
    
    - 找一道例题，例如《树》PPT第58页的例子 42。
        
    - **亲手画出**：`先根 + 中根` $\to$ 唯一的树 43。
        
    - **亲手画出**：`后根 + 中根` $\to$ 唯一的树 44。
        
5. **画转换图：**
    
    - 找一个《树》PPT第91页 45 的例子，**亲手画出** “树 $\to$ 二叉树” 的转换。
        
    - **记住规则：** **“左孩子-右兄弟”** 46464646。
        
6. **构造哈夫曼树：**
    
    - 找一个例题，例如《树》PPT第153页的 `{7, 5, 2, 4}` 47。
        
    - **亲手构造：** 严格执行“每次选取**权值最小**的两个结点合并” 48 的贪心算法，直到只剩一棵树。
        
    - **分配编码：** 左分支为0，右分支为1 49。
        

**⚖️ 深入理解标准：**

- **（基础）** 能默写5种遍历（3种递归，2种非递归）的代码。
    
- **（深入）** 能在白纸上**同时推导**一个森林的“后根遍历”和一个“森林转换成的二叉树”的“中根遍历”，并**验证两者结果一致** 50。
    

---

#### 模块五：图 (《06 第六章 图 .pdf》)

🎯 核心复习目标：

这是本课程的顶峰。必须掌握遍历、最小生成树(MST)、最短路径、拓扑排序和关键路径这五大核心算法的思想、图上模拟、时空复杂度。

**✅ 必做行动清单：**

1. **画存储结构：** 找一个有5个结点的带权图，**亲手**把它画成“邻接矩阵” 51和“邻接表” 52 两种形态。
    
2. **模拟图遍历 (核心基础)：**
    
    - **DFS (深度优先)：** 在图上模拟，并理解它天然对应“递归”（或“栈”） 。
        
    - **BFS (广度优先)：** 在图上模拟，并理解它天然对应“队列” 
        
3. **模拟最小生成树 (MST)：** 找一个带权无向图（如《图》第171页 55）。
    
    - **Prim算法 (加点法)：** 从一个点`v`开始，**亲手模拟**“不断找一条最短的边，连接一个‘已在树中’的点和一个‘不在树中’的点” 56。
        
    - **Kruskal算法 (加边法)：** **亲手模拟**“将所有边按权值排序，从小到大依次添加，只要不形成环就加入” 57。
        
4. **模拟最短路径 (Shortest Path)：** 找一个带权有向图（如《图》第144页 58）。
    
    - **Dijkstra算法 (单源)：** **亲手模拟**“`dist[]`数组更新”的过程 59。重点理解“松弛”操作：`if (dist[v] + weight(v,w) < dist[w]) then update` 60。
        
    - **Floyd算法 (所有顶点对)：** **亲手模拟** $O(n^3)$ 的三重循环 61。**必须理解**为什么 `k`（中间点）循环在最外层 62。
        
5. **模拟活动网 (Activity Nets)：**
    
    - **拓扑排序 (AOV)：** 找一个AOV网（如《图》第91页 63）。**亲手模拟**“1. 统计所有顶点入度 64； 2. 将入度为0的顶点入队 65； 3. 出队、访问、将其邻接点入度减1 66、若邻接点入度为0则入队 67”的完整过程。
        
    - **关键路径 (AOE) (最难点)：** 找一个AOE网（如《图》第104页 68）。**必须亲手计算**所有顶点的 `ve` (最早发生时间，正向拓扑) 69696969和 `vl` (最迟发生时间，逆向拓扑) 70707070。然后计算所有**活动**的 `e` (最早开始) 71717171和 `l` (最迟开始) 72727272。找出 `e(i) == l(i)` 73737373 的路径。
        

**⚖️ 深入理解标准：**

- **（基础）** 知道DFS/BFS/Prim/Kruskal/Dijkstra/Floyd/拓扑排序的复杂度 
    
- **（深入）** 给你一个现实问题，你能**立即判断**用哪个图算法。
    
    - “修路、铺设电缆、造价最低” $\to$ **MST (Prim/Kruskal)** 75。
        
    - “导航、最快路线、最省钱” $\to$ **最短路径 (Dijkstra/Floyd)**。
        
    - “大学课程、先修课、编译依赖” $\to$ **拓扑排序** 76767676。
        
    - “工程排期、最短工期” $\to$ **关键路径** 77。
        

---

#### 模块六：排序 (《07 第七章 排序_ppt.pdf》)

🎯 核心复习目标：

精通 $O(n \log n)$ 排序（快排、堆排、归并）的实现细节、性能权衡和稳定性。

**✅ 必做行动清单：**

1. **回顾 $O(n^2)$ 家族：** 知道“插入排序” 78、“冒泡排序” 79、“选择排序” 80。**重点：** 知道为什么“插入”和“冒泡”是**稳定**的 81818181，而“选择”**不稳定** 82。
    
2. **默写快速排序 (Quick Sort)：**
    
    - **核心：** **必须能默写**《排序》第39页的 `Partition` (划分) 算法 83。这是快排的灵魂。
        
    - **分析：** 在纸上推演一遍，为什么当数组“基本有序”时，快排会退化到 $O(n^2)$？（答案：Pivot 选取不当，导致递归树严重不平衡） 84。
        
3. **默写堆排序 (Heap Sort)：**
    
    - **连接知识：** 回忆“模块四”中的“完全二叉树的顺序存储” 85。
        
    - **亲手模拟 (建堆)：** 找一个无序数组（如《排序》第78页 86），从 `n/2` 位置开始，**倒着**调用 `Restore` (调整) 87，**画出**“建堆”的全过程 88。
        
    - **亲手模拟 (排序)：** **画出**后续的 $n-1$ 次“交换堆顶和堆底元素” 89-> “调整堆顶 (`Restore(1, i-1)`）” 90909090 的全过程。
        
4. **模拟归并排序 (Merge Sort)：**
    
    - **亲手模拟：** 找一个数组，**画出**“递归分解”和“合并 (Merge)” 91919191的全过程（如《排序》第101页 92）。
        
    - **分析：** 为什么它**总是** $O(n \log n)$？ 93为什么它**稳定**？ 94为什么它需要 $O(n)$ 的**额外空间**？ 95
        

**⚖️ 深入理解标准：**

- **（基础）** 能在纸上模拟一遍快排、堆排、归并排。
    
- **（深入）** 能**从内存中**默写出《排序》第108页的**“排序算法总结表”** 96。必须能准确说出这7种排序的**平均时间**、**最坏时间**、**空间**以及**稳定性**。
    

---

### 💡 最终检验 (Capstone)

当你完成了以上6个模块后，进行“期末模拟”：

找一套模拟题，或者把所有章节的习题打乱。当你抽到一道题时，你必须能够：

1. **识别问题：** “这是什么问题？”（例如：这是一个最短路径问题）。
    
2. **选择工具：** “我应该用哪种数据结构和算法？”（例如：这是个无负权单源最短路径，我应该用Dijkstra）。
    
3. **执行算法：** 能在纸上完整、准确地推演算法的执行过程。
    

如果你能做到这三点，你就真正从“模糊”达到了“深入透彻”。

你希望我们从这个复习计划中，挑选一个你最“模糊”的难点（比如 KMP 算法的 `next` 数组推导，或者关键路径的 `ve`/`vl` 计算）开始，由我来详细为你讲解一遍吗？