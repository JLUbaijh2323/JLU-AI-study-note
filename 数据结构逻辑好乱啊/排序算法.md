
---

## 排序算法基础

在开始之前，我们先明确几个基本概念：

- **排序（Sort）**：将一个文件（记录的集合）中的所有记录，按照其关键词（排序的依据）的大小，重新排列成一个有序的序列 1。
    
- **稳定性（Stability）**：如果两个关键词相同的记录 $R_i$ 和 $R_j$，$R_i$ 在排序前位于 $R_j$ 的前面，在排序后 $R_i$ **仍然**位于 $R_j$ 的前面，则称该算法是稳定的 2。
    
- **复杂度（Complexity）**：
    
    - **时间复杂度**：衡量算法好坏的最重要标准，主要通过“关键词比较次数”和“数据移动次数”来衡量 3。
        
    - **空间复杂度**：排序过程中占用的额外存储空间大小 4。
        

---

## 1. 直接插入排序 (Direct Insertion Sort)

### 算法思想

不断地将一个新元素插入到其**左侧已经排好序**的有序序列中，从而得到一个新的、更长的有序序列 5。这个过程就像我们整理手中的扑克牌，每次拿到一张新牌，就把它插入到手里已有牌的正确位置。

### 算法流程

1. 从第 2 个元素（下标为 2，假设数组从 1 开始）开始，将其视为要插入的“新牌”，记为 `K` 6。
    
2. 设置一个指针 `j`，从 `i-1` 开始向前（向左）扫描 777。
    
3. **比较与后移**：如果 `R[j]` 大于 `K`，说明 `K` 应该在 `R[j]` 的前面，于是将 `R[j]` 向后移动一位到 `R[j+1]`，然后 `j` 继续向前 8888。
    
4. **找到位置**：重复步骤 3，直到找到一个 `R[j]` 小于或等于 `K`（找到了插入位置），或者 `j` 已经到了数组开头 9。
    
5. **插入**：将 `K` 放入 `R[j+1]` 的位置 10。
    
6. 重复这个过程，直到最后一个元素 `R[n]` 也被插入到正确位置。
    

### C++ 代码


```cpp
/* * 直接插入排序 [cite: 2367-2379]
 * 对 R[1]...R[n] 进行排序
 */
void InsertionSort(int R[], int n) { 
    // R[1]...R[i-1] 是有序区，R[i] 是待插入元素
    for(int i=2; i<=n; i++){ 
        int K = R[i]; // 哨兵，存放待插入元素
        int j = i-1; 
        
        // 从右往左在有序区 R[1...i-1] 中查找插入位置
        // R[j] > K 时，将 R[j] 后移
        while(j>=1 && R[j]>K){ 
            R[j+1] = R[j]; 
            j--; 
        }
        
        // 找到了插入位置 j+1
        R[j+1] = K; 
    }
}
```

### 时间复杂度计算

- **最好情况**：数组**已经有序** 11。
    
    - 每次插入时，`R[i]` 只需要和它前面的 `R[i-1]` 比较 1 次 12。外层循环 `n-1` 次，总比较次数为 $O(n)$ 13。
        
- **最坏情况**：数组**逆序** 14。
    
    - 第 `i` 个元素需要和前面所有 `i-1` 个元素进行比较和移动 15。
        
    - 总比较/移动次数为 $1 + 2 + ... + (n-1) = \frac{n(n-1)}{2}$，因此时间复杂度为 $O(n^2)$ 16。
        
- **平均情况**：$O(n^2)$ 17。
    

### 算法优点与总结

- **空间复杂度**：$O(1)$ 18。
    
- **稳定性**：**稳定** 19。
    
- **优点**：在待排序文件“基本有序”或数据量很“短”时，速度非常快 20。
    

---

## 2. 冒泡排序 (Bubble Sort)

### 算法思想

从左到右依次比较**相邻**的两个元素，如果它们是“反序对”（即前面的元素大于后面的元素），就交换它们 21。这样一趟扫描下来，最大的元素就像“气泡”一样，“浮”到了数组的最右边 22。

### 算法流程

1. 进行多趟冒泡。`bound` 变量记录当前无序区的右边界，初始为 `n` 2323。
    
2. 在一趟冒泡中，从 `i=1` 扫描到 `bound-1` 24。
    
3. 如果 `R[i] > R[i+1]`，则交换它们，并用变量 `t` 记录下最后发生交换的位置 `i` 25252525。
    
4. 一趟结束后，`R[bound]` 到 `R[n]` 已经是排好序的。
    
5. **优化**：将 `bound` 更新为 `t` 26。如果某一趟没有发生任何交换（`t=0`），说明数组已经完全有序，`bound` 变为 0，排序提前结束 272727。
    

### C++ 代码


```cpp
/* * 冒泡排序（优化版） [cite: 2647-2655]
 * 增加了 bound 标记，用于记录本趟冒泡元素交换的最后位置
 */
void BubbleSort(int R[], int n){
    int bound = n; // 每趟冒泡关键词比较的终止位置
    while(bound > 0){
        int t = 0; // 本趟冒泡元素交换的最后位置
        for(int i=1; i < bound; i++){
            if(R[i] > R[i+1]){ 
                swap(R[i], R[i+1]); 
                t = i; // 记录最后交换的位置
            }
        }
        bound = t; // 下一趟冒泡的终止位置
    }
}
```

### 时间复杂度计算

- **最好情况**：数组**已经有序** 28。
    
    - 第一趟冒泡时，`if` 条件一次都不成立，`t` 保持为 0，`bound` 更新为 0，`while` 循环终止 29。只进行了一趟比较，时间复杂度为 $O(n)$ 30。
        
- **最坏情况**：数组**逆序** 31。
    
    - 需要进行 $O(n)$ 趟冒泡，每趟冒泡都要比较和交换 $O(n)$ 次 32。
        
    - 总时间复杂度为 $O(n^2)$ 33。
        
- **平均情况**：$O(n^2)$ 34。
    

### 算法优点与总结

- **空间复杂度**：$O(1)$ 35。
    
- **稳定性**：**稳定** 36。当 `R[i] == R[i+1]` 时不交换，保证了稳定性 37。
    
- **优点**：实现简单，在数据基本有序时效率较高。
    

---

## 3. 直接选择排序 (Direct Selection Sort)

### 算法思想

思路非常直接：在“未排序”的元素中，找到**最大**（或最小）的那个，把它交换到未排序部分的**末尾**（或开头），从而“已排序”的区域不断扩大，未排序的区域不断缩小 38。

### 算法流程

1. 外层循环 `i` 从 `n` 递减到 `2`。`R[1...i]` 是当前待处理的子数组 39393939。
    
2. 在内层循环中，在 `R[1...i]` 范围里查找最大元素的下标 `max` 40。
    
3. 将最大元素 `R[max]` 与当前范围的最后一个元素 `R[i]` 交换 41。
    
4. 此时 `R[i]` 已经“就位”（即在它最终的正确位置上）。
    
5. `i` 减 1，缩小未排序区域，重复该过程，直到 `i=1` 42424242。
    

### C++ 代码



```cpp
/* * 直接选择排序 [cite: 2825-2837]
 * 每次从 R[1...i] 中选出最大者，与 R[i] 交换
 */
void SelectionSort(int R[], int n){
    // i 标识当前处理的子数组的右边界
    for(int i=n; i>=2; i--){ 
        
        // 在子数组 R[1]...R[i] 里找最大元素
        int max = 1; // 假设 R[1] 最大
        for(int j=2; j<=i; j++){
            if(R[j] > R[max]) 
                max = j; // max 始终记录最大元素的下标
        }
        
        // 将最大元素 R[max] 与 R[i] 交换
        swap(R[max], R[i]);
    }
}
```

### 时间复杂度计算

- **最好、最坏和平均情况**：
    
    - 无论数组的初始顺序如何，算法都必须执行完整的两层循环来找到最大值 43。
        
    - 外层循环 `n-1` 次，内层循环 `i` 次。
        
    - 总比较次数为 $\sum_{i=2}^{n} (i-1) = 1 + 2 + ... + (n-1) = \frac{n(n-1)}{2}$。
        
    - 因此，时间复杂度始终为 $O(n^2)$ 444444。
        

### 算法优点与总结

- **空间复杂度**：$O(1)$ 45。
    
- **稳定性**：**不稳定** 46。
    
    - 例如 `[5, 5*, 2]`，第一趟会找到 `5`（第一个）为最大值（假设从左到右找），与 `2` 交换，得到 `[2, 5*, 5]`，`5*` 跑到了 `5` 的后面，稳定性被破坏 47474747。
        
- **优点**：数据**移动次数**（交换次数）非常少，固定为 $O(n)$ 次。如果数据移动的成本远高于比较的成本，选择排序有一定优势。
    

---

## 4. 堆排序 (Heap Sort)

### 算法思想

堆排序是对直接选择排序的一种巧妙改进。直接选择排序在 $O(n)$ 的未排序序列中找最大值，花费 $O(n)$ 时间；而堆排序利用“堆”这个数据结构，能在 $O(\log n)$ 时间内找到最大值。

堆（Heap）：一个逻辑上的完全二叉树 48，物理上存储在数组中 49494949。

大根堆（Max Heap）：任意节点的值都大于等于其左右孩子的值 50505050。

堆的性质：大根堆的根节点（R[1]）永远是整个堆中的最大元素 51。

### 算法流程

1. **初始建堆 (BuildHeap)**：
    
    - 将待排序的数组 `R[1...n]` 调整为一个大根堆 525252。
        
    - 这是通过"Floyd建堆算法"实现的：从最后一个非叶子节点（`n/2`）开始，倒序遍历到根节点（`1`），对每个节点执行一次**下沉 (ShiftDown)** 操作 535353535353535353。
        
2. **排序阶段**：
    
    - 循环 `i` 从 `n` 递减到 `2` 545454。
        
    - **交换**：此时 `R[1]` 是堆中（即 `R[1...i]` 中）的最大元素 5555。将 `R[1]` 与堆的最后一个元素 `R[i]` 交换 56565656。
        
    - **就位**：`R[i]` 此时已是最终排好序的位置（它是第 `i` 大的元素）。
        
    - **重建堆**：将堆的大小减 1（排除 `R[i]`）。交换到 `R[1]` 的新元素可能破坏了堆的性质，因此对其执行**下沉 (ShiftDown)** 操作，使其下沉到合适位置，恢复 `R[1...i-1]` 为大根堆 575757。
        
    - 重复这个“取顶、交换、下沉”的过程，直到堆中只剩一个元素。
        

### C++ 代码

```cpp
/* * 核心操作：下沉 [cite: 1549-1571]
 * 将 R[i] 在 R[1...n] 范围内向下调整
 */
void ShiftDown(int R[], int n, int i) {
    int maxchd; // R[i] 的最大孩子的下标
    while (i <= n/2) { // i 是非叶结点
        // 找出 R[i] 较大的孩子
        if((2*i+1 <= n) && (R[2*i] < R[2*i+1]))
            maxchd = 2*i+1; // 有右孩子且右孩子大
        else 
            maxchd = 2*i; // 否则左孩子（或只有左孩子）
        
        // R[maxchd] 是 R[i] 的最大孩子
        if(R[maxchd] <= R[i])
            return; // R[i] 比最大孩子还大，满足堆序，结束
        
        // R[i] 的最大孩子比 R[i] 大，交换
        swap(R[maxchd], R[i]); 
        
        i = maxchd; // 结点 i 继续下沉
    }
}

/* * 初始建堆（Floyd 算法） [cite: 1718-1721]
 * 从最后一个非叶结点 n/2 开始，依次下沉
 */
void BuildHeap(int R[], int n){
    for(int i=n/2; i>=1; i--)
        ShiftDown(R, n, i); 
}

/* * 堆排序主函数 [cite: 2110-2123]
 */
void HeapSort(int R[], int n) { 
    // 1. 将 R 建为大根堆
    BuildHeap(R, n); 
    
    // 2. 循环 n-1 次，每次取出堆顶（最大值）放
    for(int i=n; i>=2; i--) { 
        // 将堆顶 R[1] 与堆尾 R[i] 交换
        swap(R[1], R[i]); 
        // 下沉 R[1]，使 R[1...i-1] 重建为堆
        ShiftDown(R, i-1, 1); 
    }
}
```

### 时间复杂度计算

- `ShiftDown` 操作：最多沿着堆的高度下沉，堆高为 $O(\log n)$，所以 `ShiftDown` 的时间复杂度为 $O(\log n)$ 58585858。
    
- `BuildHeap` 操作：调用了 `n/2` 次 `ShiftDown`。虽然直觉是 $O(n \log n)$，但精确计算（基于所有节点高度之和小于 `n`）表明，其时间复杂度为 $O(n)$ 59595959595959595959595959595959。
    
- `HeapSort` 总体：
    
    1. `BuildHeap` 花费 $O(n)$ 60。
        
    2. 排序阶段的 `for` 循环执行 `n-1` 次 61。
        
    3. 循环体内每次调用 `ShiftDown` 花费 $O(\log n)$ 62。
        
    4. 总时间 = $O(n) + (n-1) \times O(\log n) = O(n \log n)$ 63。
        
- **最好、最坏和平均情况**：堆排序的流程是固定的，不受数据初始顺序影响，因此所有情况下的时间复杂度都是 $O(n \log n)$ 64。
    

### 算法优点与总结

- **空间复杂度**：$O(1)$ 65。
    
- **稳定性**：**不稳定** 66。
    
- **优点**：提供了 $O(n \log n)$ 的最坏情况时间复杂度，且不需要额外空间。
    

---

## 5. 快速排序 (Quick Sort)

### 算法思想

快速排序被认为是（基于比较的）内部排序算法中**平均情况下最快**的 6767。它采用“**分治法**”（Divide and Conquer） 68。

1. **分 (Divide)**：选取一个“基准元素”（Pivot） 69。
    
2. **治 (Conquer via Partition)**：执行一次“**分划 (Partition)**”操作，将数组重新排列。使得所有**小于等于**基准的元素都在其左边，所有**大于**基准的元素都在其右边。操作结束后，该基准元素就位于其最终的正确位置上 70707070。
    
3. **合 (Combine)**：对基准元素左、右两个独立的子数组，**递归**地重复上述过程 71717171。
    

### 算法流程 (Partition 操作)

1. 选取基准 `K`（通常是第一个元素 `R[m]`） 72。
    
2. 设置两个指针：`L` 从 `m` 开始向右，`G` 从 `n+1` 开始向左 73。
    
3. `L` 指针**向右**扫描，跳过所有 $\le K$ 的元素，停在第一个 $> K$ 的元素上 74747474。
    
4. `G` 指针**向左**扫描，跳过所有 $> K$ 的元素，停在第一个 $\le K$ 的元素上 75757575。
    
5. 如果 `L < G`，说明 `L` 找到了一个“大”值，`G` 找到了一个“小”值，交换 `R[L]` 和 `R[G]` 76。
    
6. 重复 3-5 步，直到 `L >= G`（两指针相遇或错过） 77。
    
7. 最后，将基准元素 `R[m]` 与 `R[G]` 交换 78。
    
8. 返回 `G`，这就是基准元素的新位置 79。
    

### C++ 代码

```cpp
/* * 核心操作：分划 (Partition) [cite: 3241-3267]
 * 对 R[m...n] 进行分划，R[m] 为基准元素
 * 返回基准元素就位后的下标
 */
int Partition(int R[], int m, int n) { 
    int K = R[m]; 
    int L = m, G = n+1; // R[m] 为基准元素
    
    while(L < G) {
        // L 从左向右找第一个 > K 的元素
        do { L++; } while(L<=n && R[L]<=K);
        
        // G 从右向左找第一个 <= K 的元素
        do { G--; } while(R[G]>K);
        
        if(L < G) 
            swap(R[L], R[G]);
    }
    
    // 将基准 R[m] 换到 G 的位置
    swap(R[m], R[G]); 
    return G; // 返回基准的最终位置
}

/* * 快速排序主函数（递归） [cite: 3488-3494]
 * 对 R[m...n] 递增排序
 */
void QuickSort(int R[], int m, int n){ 
    if(m < n){
        // j 是基准元素的位置
        int j = Partition(R, m, n); 
        // 递归排序左半部分
        QuickSort(R, m, j-1); 
        // 递归排序右半部分
        QuickSort(R, j+1, n); 
    }
}
```

### 时间复杂度计算

- `Partition` 操作的时间复杂度是 $O(n)$，因为它只需要扫描一次子数组 80808080。
    
- **最好情况**：每次分划都发生在**最中间** 81818181。
    
    - 递归树的高度为 $O(\log n)$ 82。
        
    - 每层递归的所有 `Partition` 操作加起来总共是 $O(n)$ 83838383。
        
    - 总时间 = $O(n) \times O(\log n) = O(n \log n)$ 84。
        
- **最坏情况**：每次分划都发生在**最边上**（例如数组已经有序或逆序） 85858585。
    
    - 递归树高度退化为 $n$。
        
    - 总时间 = $O(n) + O(n-1) + ... + O(1) = O(n^2)$ 86。
        
- **平均情况**：可以证明（讲义 34-42 页），即使分划不平衡，平均时间复杂度也是 $O(n \log n)$ 87878787。
    

### 算法优点与总结

- **空间复杂度**：$O(\log n) \sim O(n)$。主要用于递归函数栈 8888。最好/平均情况是 $O(\log n)$ 89，最坏情况是 $O(n)$ 90。
    
- **稳定性**：**不稳定** 91919191。
    
- **优点**：平均情况下的常系数非常小，使其在实践中速度极快 92929292。同时，它访问数据具有良好的“空间局部性”（倾向于访问相邻数据），缓存命中率高 93939393。
    

---

## 6. 归并排序 (Merge Sort)

### 算法思想

归并排序是**最快**的**稳定**排序算法 94。它同样采用“**分治法**” 95。

1. **分 (Divide)**：不断地把数组**对半**分成两个子数组，直到每个子数组只剩下一个元素 96。
    
2. **治 (Conquer via Merge)**：将两个已经排好序的子数组，**合并（Merge）**成一个更大的、排好序的数组 97。
    
3. **合 (Combine)**：这个合并的过程从底向上（从 1 个元素的数组开始）不断进行，直到整个数组合并完毕。
    

### 算法流程 (Merge 操作)

`Merge(R, low, mid, high)` 是算法的核心 98。

1. 申请一个临时数组 `X`，大小为 `high - low + 1` 99。
    
2. 设置三个指针：`i` 指向左半数组（`R[low...mid]`）的开头，`j` 指向右半数组（`R[mid+1...high]`）的开头，`k` 指向 `X` 的开头 100。
    
3. **比较和复制**：当 `i` 和 `j` 都在范围内时，比较 `R[i]` 和 `R[j]` 101。
    
    - 将**较小**的元素复制到 `X[k]` 102。
        
    - 移动对应的指针（`i` 或 `j`）和 `k` 指针 103。
        
4. **处理剩余**：当一个子数组处理完毕后（例如 `i > mid`），将另一个子数组（`R[j...high]`）中所有剩余元素直接复制到 `X` 中 104。
    
5. **拷回**：将临时数组 `X` 中的所有元素，按顺序拷回原数组 `R` 的 `R[low...high]` 位置 105。
    

### C++ 代码

```cpp
/* * 核心操作：合并 (Merge) [cite: 178-190]
 * 将两个相邻的有序数组 (R[low...mid]) 和 (R[mid+1...high])
 * 合并成一个有序数组
 */
void Merge(int R[], int low, int mid, int high){
    int i=low, j=mid+1, k=0; 
    int *X = new int[high-low+1]; // 申请临时空间
    
    // 比较 R[i] 和 R[j]，将较小者放入 X
    while(i<=mid && j<=high) {
        if(R[i] <= R[j]) 
            X[k++] = R[i++];
        else 
            X[k++] = R[j++];
    }
    
    // 复制左半数组的剩余记录
    while(i<=mid) 
        X[k++] = R[i++];
    
    // 复制右半数组的剩余记录
    while(j<=high) 
        X[k++] = R[j++];
    
    // 将 X 拷贝回 R
    for(i=0; i<high-low+1; i++) 
        R[low+i] = X[i];
        
    delete []X; // 释放临时空间
}

/* * 归并排序主函数（递归） [cite: 194-204]
 * 采用分治法（自顶向下）
 */
void MergeSort(int R[], int m, int n){
    if(m >= n) return; // 递归终止
    
    int k = (m+n)/2; // 找到中间点
    
    MergeSort(R, m, k);     // 递归排序左半部分
    MergeSort(R, k+1, n); // 递归排序右半部分
    
    Merge(R, m, k, n);    // 合并
}
```

### 时间复杂度计算

- `Merge` 操作：需要遍历两个子数组的所有元素，并将它们复制到临时数组，然后再拷回。总元素为 `n`（即 `high-low+1`），时间复杂度为 $O(n)$ 106106。
    
- `MergeSort` 总体：
    
    - 递归将数组分成了 $O(\log n)$ 层 107。
        
    - 在每一层，所有 `Merge` 操作的总工作量都是 $O(n)$（例如，第 1 层是 1 次 $O(n)$ 合并，第 2 层是 2 次 $O(n/2)$ 合并...） 108108108108108108108108108。
        
    - 总时间 = (层数) $\times$ (每层工作量) = $O(\log n) \times O(n) = O(n \log n)$ 109。
        
- **最好、最坏和平均情况**：归并排序的流程是固定的，它总是执行相同的对半分割和合并，不受数据初始顺序的影响。因此，所有情况下的时间复杂度都是 $O(n \log n)$ 110。
    

### 算法优点与总结

- **空间复杂度**：$O(n)$ 111。这是归并排序的主要缺点，它需要一个与原数组同样大小的临时数组 112112112112。
    
- **稳定性**：**稳定** 113。在 `Merge` 操作中，当 `R[i] == R[j]` 时，我们总是先放 `R[i]`（来自左边的元素），这保证了稳定性 114。
    
- **优点**：最坏情况时间复杂度优秀，且是稳定的，是**最快的稳定排序算法** 115。它也常用于“外排序”（External Sorting） 116116116116。
    

---

## 排序算法总览

最后，这是一张总结所有算法特性的对比表 117117117117117117117117117：

| **排序算法**   | **最好时间**      | **平均时间**                 | **最坏时间**      | **空间复杂度**   | **稳定性** |
| ---------- | ------------- | ------------------------ | ------------- | ----------- | ------- |
| **直接插入排序** | $O(n)$        | $O(n^2)$                 | $O(n^2)$      | $O(1)$      | **稳定**  |
| **冒泡排序**   | $O(n)$        | $O(n^2)$                 | $O(n^2)$      | $O(1)$      | **稳定**  |
| **直接选择排序** | $O(n^2)$      | $O(n^2)$                 | $O(n^2)$      | $O(1)$      | 不稳定     |
| **希尔排序**   | -             | $O(n^{1.3}\sim n^{1.5})$ | $O(n^2)$      | $O(1)$      | 不稳定     |
| **堆排序**    | $O(n \log n)$ | $O(n \log n)$            | $O(n \log n)$ | $O(1)$      | 不稳定     |
| **快速排序**   | $O(n \log n)$ | $O(n \log n)$            | $O(n^2)$      | $O(\log n)$ | 不稳定     |
| **归并排序**   | $O(n \log n)$ | $O(n \log n)$            | $O(n \log n)$ | $O(n)$      | **稳定**  |

希望这份讲解对您有所帮助！您想不想了解一下这些排序算法在什么具体场景下表现最好？